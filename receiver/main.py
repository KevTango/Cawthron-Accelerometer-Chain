# Receiver code for Cawthron Institute's mussel farm accelerometer chain# Author: Kevin Tangfrom machine import I2C, Pin, SPI, UARTfrom lis3dh import LIS3DH, LIS3DH_I2C, RANGE_2_G, DATARATE_1_HZfrom pyb import ADC, RTCfrom ds3231_port import DS3231import timeimport osimport sysimport mathif sys.platform == 'pyboard':  # Initialising pins  thermistor = pyb.ADC('Y12')  tx_enable = Pin('X20', Pin.OUT)    # Initialising I2C  i2c = I2C(1)  rtc_i2c = I2C(2)  ds3231 = DS3231(rtc_i2c)    # Initialising UART  uart = UART(6, 9600)  uart.init(9600, bits=8, parity=None, stop=1, timeout=0) # Non-blocking UARTelse:  print('Incompatible board detected, please connect pyboard')ID = 0 # Receiver ID (0-9). MAKE SURE TO CHANGEaccelerometer = LIS3DH_I2C(i2c, int1=None)# Date initialisationrtc = RTC()timeCheck = ds3231.get_time() # Gets current timertc.datetime((timeCheck[0], timeCheck[1], timeCheck[2], timeCheck[6], timeCheck[3], timeCheck[4], timeCheck[5], 0)) # Syncs RTC clock to local time"""# Sets up RTC clock, uncomment to manually set the clock (NOTE: DAY OF WEEK AND TIME ZONE IS NOT WORKING)rtc.datetime((2020, 1, 20, 1, 10, 3, 40, 0))  # Comment out if already programmedds3231.save_time()# RTC Format: YY, MM, DD, Day of week (Mon = 1), hh, mm, ss, time zone# Example: 16/12/2019 @ Monday 16:13:00# = rtc.datetime((2019, 12, 16, 1, 16, 13, 0, 0))"""# Retrieves datedef getDate():  return str(rtc.datetime()[2]) + '/' + str(rtc.datetime()[1]) + '/' + str(rtc.datetime()[0])# Retrieves timedef getTime():  return str(rtc.datetime()[4]) + ':' + str(rtc.datetime()[5]) + ':' + str(rtc.datetime()[6])LIS3DH.range = RANGE_2_G # Setting range to 2GLIS3DH.datarate = DATARATE_1_HZ # Setting data rate to 1 Hz# Buffer values for acceleration valuesxBuffer = 0yBuffer = 0zBuffer = 0# Low power millisecond delaydef msTimer(ms):  if pyb.Pin.board.USB_VBUS.value() == 1: #pyb.stop() will kill USB connection to pyboard    time.sleep((ms/1000))  else:    rtc.wakeup(ms) # Allows the Pyboard to wake up every second    pyb.stop() # Pyboard will enter low power mode to conserve battery life    rtc.wakeup(None)    # Low power minute delaydef minTimer(minute):  if pyb.Pin.board.USB_VBUS.value() == 1: #pyb.stop() will kill USB connection to pyboard    time.sleep((minute*60))  else:    rtc.wakeup((minute*60*1000)) # Allows the Pyboard to wake up every second    pyb.stop() # Pyboard will enter low power mode to conserve battery life    rtc.wakeup(None)while True:  tx_enable.value(0)  read = uart.read()  idCheck = str(read)[2]  print(idCheck)    print(getDate()) # Date  print(getTime()) # Time    # Print X,Y,Z acceleration values in m/s^2  x, y, z = [value for value in accelerometer.acceleration]  xRounded = round(x, 2)  xRounded = round(x, 2)  yRounded = round(y, 2)  zRounded = round(z, 2)  print(xRounded, yRounded, zRounded)    # Thermistor readings  thermistorTest = thermistor.read() / 4095  thermistorTest *= 100  thermistorRounded = round(thermistorTest, 2)  print(thermistorRounded)    if(idCheck == str(ID)):    try:      if((abs(abs(xRounded - xBuffer) / xBuffer)) < 0.1) and ((abs(abs(yRounded - yBuffer) / yBuffer)) < 0.1) \      and ((abs(abs(zRounded - zBuffer) / zBuffer)) < 0.1):        print('Going to sleep')        minTimer(15)        xBuffer = 0        yBuffer = 0        zBuffer = 0    except ZeroDivisionError:      continue    tx_enable.value(1)    print(uart.write(str(ID) + ',' + str(xRounded) + ',' + str(yRounded) + ',' + str(zRounded) + ',' + str(thermistorRounded)))    tx_enable.value(0)    idCheck = str(99) # Arbitary reset number    print()    xBuffer = xRounded  yBuffer = yRounded  zBuffer = zRounded    pyb.LED(4).on()  time.sleep(1)