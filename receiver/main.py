# Receiver code for Cawthron Institute's mussel farm accelerometer chain# Author: Kevin Tangfrom machine import I2C, Pin, SPI, UART, WDTfrom lis3dh import LIS3DH, LIS3DH_I2C, RANGE_2_G, DATARATE_10_HZ, STANDARD_GRAVITYfrom pyb import ADC, RTCfrom ds3231_port import DS3231import timeimport osimport sysimport mathglobal IDglobal timerID = 0 # Receiver ID (0-9). MAKE SURE TO CHANGEtimer = 1 # By default, sleep value is set to 1s (1 Hz mode)# Enable Watchdog timer. UNCOMMENT WHEN IN USE. COMMENT IF CHANGES ARE NEEDED IN IDEwdt = WDT(timeout=10000) # enable with a timeout of 10 secondsif sys.platform == 'pyboard':  # Initialising pins  thermistor = pyb.ADC('Y12')  tx_enable = Pin('X20', Pin.OUT)    # Initialising I2C  i2c = I2C(1) # Pins X9 and X10  rtc_i2c = I2C(2) # Pins Y9 and Y10  ds3231 = DS3231(rtc_i2c)  accelerometer = LIS3DH_I2C(i2c, int1=None)    # Initialising UART  uart = UART(4, 115200) # Pins X1 and X2  uart.init(115200, bits=8, parity=None, stop=1, timeout=0) # Non-blocking UARTelse:  print('Incompatible board detected, please connect pyboard')# Date initialisationrtc = RTC()timeCheck = ds3231.get_time() # Gets current timertc.datetime((timeCheck[0], timeCheck[1], timeCheck[2], timeCheck[6], timeCheck[3], timeCheck[4], timeCheck[5], 0)) # Syncs RTC clock to local time"""# Sets up RTC clock, uncomment to manually set the clock (NOTE: DAY OF WEEK AND TIME ZONE IS NOT WORKING)rtc.datetime((2020, 1, 20, 1, 10, 3, 40, 0))  # Comment out if already programmedds3231.save_time()# RTC Format: YY, MM, DD, Day of week (Mon = 1), hh, mm, ss, time zone# Example: 16/12/2019 @ Monday 16:13:00# = rtc.datetime((2019, 12, 16, 1, 16, 13, 0, 0))"""# Function to create and write headers for the accelerometer csvdef writeHeader():  print('writing headers')  log_header = open("/sd/accelerometer.csv", "a")  log_header.write("ID, Date, Time, X Acceleration, Y Acceleration, Z Acceleration, Temperature \n")  log_header.close()# Retrieves datedef getDate():  return str(rtc.datetime()[2]) + '/' + str(rtc.datetime()[1]) + '/' + str(rtc.datetime()[0])# Retrieves timedef getTime():  return str(rtc.datetime()[4]) + ':' + str(rtc.datetime()[5]) + ':' + str(rtc.datetime()[6])LIS3DH.range = RANGE_2_G # Setting range to 2GLIS3DH.datarate = DATARATE_10_HZ # Setting data rate to 10 HzdataBuffer = str()# Checks to see if the csv file is empty, then writes the file if it is emptytry:  with open("/sd/accelerometer.csv") as fileEmptyTest:    emptyTest = fileEmptyTest.read(1)    if not emptyTest:      writeHeader()    else:      print('csv file is not empty')except OSError: # File does not exist, make the files and headers  writeHeader()  while True:  wdt.feed() # Kicks watchdog timer  tx_enable.value(0)  read = uart.read()  idCheck = str(read)[2]  modeCheck = str(read)[2:-1]    print(getDate()) # Date  print(getTime()) # Time    # Print X,Y,Z acceleration values in g forces  x, y, z = [value for value in accelerometer.acceleration]    x = x / STANDARD_GRAVITY  y = y / STANDARD_GRAVITY  z = z / STANDARD_GRAVITY    xRounded = round(x, 2)  xRounded = round(x, 2)  yRounded = round(y, 2)  zRounded = round(z, 2)  #print(xRounded, yRounded, zRounded)    # Thermistor readings  thermistorTest = thermistor.read() / 4095  thermistorTest *= 100  thermistorRounded = round(thermistorTest, 2)  #print(thermistorRounded)    # Write data to csv file  log_header = open("/sd/accelerometer.csv", "a")  log_header.write(str(ID) + ", " + getDate() + ", " + getTime() + ", " + str(xRounded) + ", " + str(yRounded) + ", " + \  str(zRounded) + ", " + str(thermistorRounded) + " \n")  log_header.close()    dataString = str(ID) + ',' + getDate() + ',' + getTime() + ',' + str(xRounded) + ',' + str(yRounded) + ',' + str(zRounded) + ',' + str(thermistorRounded) + "..."    dataBuffer += dataString    # Adjusts mode based on datalogger and clears buffer to prevent overflow  if(modeCheck == 'one'):    dataBuffer = str()    timer = 1    print('cleared')  elif(modeCheck == 'two'):    dataBuffer = str()    timer = 0.5    print('cleared')    if(idCheck == str(ID)):    tx_enable.value(1)    print(uart.write(str(dataBuffer)))    pyb.LED(2).on() # Debug LED    tx_enable.value(0)    dataBuffer = str() # Clear buffer once it sends the data values    idCheck = str(99) # Arbitary reset number      print()  pyb.LED(2).off()    time.sleep(timer)