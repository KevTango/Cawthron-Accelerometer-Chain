# Receiver code for Cawthron Institute's mussel farm accelerometer chain# Author: Kevin Tang"""DEFAULT VALUESMODE: 1 HZBAUD RATE: 9600DATA FRAME: bits=8, parity=None, stop=1, timeout=0ACCELEROMETER RANGE: 2GACCELEROMETER FREQUENCY: 10 HZ"""from machine import I2C, Pin, SPI, UART, WDTfrom lis3dh import LIS3DH, LIS3DH_I2C, RANGE_2_G, DATARATE_10_HZ, STANDARD_GRAVITYfrom pyb import ADC, RTCfrom ds3231_port import DS3231import timeimport osimport sysimport mathglobal IDglobal timerID = 0 # Receiver ID (0-9). MAKE SURE TO CHANGEtimer = 1 # By default, sleep value is set to 1s (1 Hz mode)# Enable Watchdog timer if using batteryglobal TIMEOUT_VALUETIMEOUT_VALUE = 5000if pyb.Pin.board.USB_VBUS.value() == 0:  wdt = WDT(timeout = TIMEOUT_VALUE) # enable with a timeout of 5 secondsif sys.platform == 'pyboard':  # Initialising pins  thermistor = pyb.ADC('Y12')  tx_enable = Pin('X20', Pin.OUT)    # Initialising I2C  i2c = I2C(1) # Pins X9 and X10  rtc_i2c = I2C(2) # Pins Y9 and Y10  ds3231 = DS3231(rtc_i2c)  accelerometer = LIS3DH_I2C(i2c, int1=None)    # Initialising UART  uart = UART(4, 115200) # Pins X1 and X2  uart.init(115200, bits=8, parity=None, stop=1, timeout=0) # Non-blocking UARTelse:  print('Incompatible board detected, please connect pyboard')# Date initialisationrtc = RTC()timeCheck = ds3231.get_time() # Gets current timertc.datetime((timeCheck[0], timeCheck[1], timeCheck[2], timeCheck[6], timeCheck[3], timeCheck[4], timeCheck[5], 0)) # Syncs RTC clock to local time"""# Sets up RTC, uncomment to manually set the clock (NOTE: DAY OF WEEK AND TIME ZONE IS NOT WORKING)rtc.datetime((2020, 2, 11, 2, 15, 48, 50, 0))  # Comment out if already programmedds3231.save_time()# RTC Format: YY, MM, DD, Day of week (Mon = 1), hh, mm, ss, time zone# Example: 16/12/2019 @ Monday 16:13:00# = rtc.datetime((2019, 12, 16, 1, 16, 13, 0, 0))"""# Function to create and write headers for the accelerometer csvdef writeHeader():  print('writing header')  log_header = open("/sd/accelerometer.csv", "a")  log_header.write("ID, Date, Time, X Acceleration, Y Acceleration, Z Acceleration, Temperature \n")  log_header.close()# Retrieves datedef getDate():  return str(rtc.datetime()[2]) + '/' + str(rtc.datetime()[1]) + '/' + str(rtc.datetime()[0])# Retrieves timedef getTime():  return str(rtc.datetime()[4]) + ':' + str(rtc.datetime()[5]) + ':' + str(rtc.datetime()[6]) # Low power delaydef rest():  if pyb.Pin.board.USB_VBUS.value() == 1:    time.sleep(timer)  else:    rtc.wakeup(timer*1000)    pyb.stop()    rtc.wakeup(None)  LIS3DH.range = RANGE_2_G # Setting range to 2G (increasing the value to 4G will double the g force which is inaccurate)LIS3DH.datarate = DATARATE_10_HZ # Setting data rate to 10 HzdataBuffer = str() # Initialising empty string# Checks to see if the csv file is empty, then writes the file if it is emptytry:  with open("/sd/accelerometer.csv") as fileEmptyTest:    emptyTest = fileEmptyTest.read(1)    if not emptyTest:      writeHeader()    else:      print('csv file is not empty')except OSError: # File does not exist, make the files and headers  writeHeader()  while True:  if pyb.Pin.board.USB_VBUS.value() == 0:    wdt.feed() # Kicks watchdog timer  tx_enable.value(0)  read = uart.read()  idCheck = str(read)[-2]  modeCheck = str(read)[2:5]    print(getDate()) # Date  print(getTime()) # Time    if timer == 1:    print("MODE: 1 HZ")  else:    print("MODE: 2 HZ")    # Print X,Y,Z acceleration values in g forces  x, y, z = [value for value in accelerometer.acceleration]    x = x / STANDARD_GRAVITY  y = y / STANDARD_GRAVITY  z = z / STANDARD_GRAVITY    xRounded = round(x, 2)  xRounded = round(x, 2)  yRounded = round(y, 2)  zRounded = round(z, 2)  print("Acceleration: " + str(xRounded) + ", " + str(yRounded) + ", " + str(zRounded))    # Thermistor readings  thermistorTest = thermistor.read() / 4095  thermistorTest *= 100  thermistorRounded = round(thermistorTest, 2)  print("Temperature: " + str(thermistorRounded))    # Write data to csv file  log_header = open("/sd/accelerometer.csv", "a")  log_header.write(str(ID) + ", " + getDate() + ", " + getTime() + ", " + str(xRounded) + ", " + str(yRounded) + ", " + \  str(zRounded) + ", " + str(thermistorRounded) + " \n")  log_header.close()    dataString = str(ID) + ',' + getDate() + ',' + getTime() + ',' + str(xRounded) + ',' + str(yRounded) + ',' + str(zRounded) + ',' + str(thermistorRounded) + "..."  dataBuffer += dataString    # Adjusts mode based on datalogger and clears buffer to prevent overflow  if modeCheck == 'one':    dataBuffer = str()    print('ok')    timer = 1    print('cleared')  elif modeCheck == 'two':    dataBuffer = str()    timer = 0.5    print('cleared')  elif modeCheck == 'uno':    timer = 1  elif modeCheck == 'dos':    timer = 0.5    if idCheck == str(ID):    tx_enable.value(1)    print(uart.write(str(dataBuffer)))    pyb.LED(2).on() # Debug LED    tx_enable.value(0)    dataBuffer = str() # Clear buffer once it sends the data values    idCheck = str(99) # Arbitary reset number    print('transmit')      print()  pyb.LED(2).off()    rest()